{"version":3,"sources":["components/EntityLabeler/models.ts","components/EntityLabeler/utils.ts","components/FuseMatch/FuseMatch.tsx","components/EntityLabeler/usePicker.ts","components/FuseMatch/utilities.ts","components/EntityLabeler/EntityPicker.tsx","components/EntityLabeler/CustomElements/EntityElement.tsx","components/EntityLabeler/CustomElements/ParagraphElement.tsx","components/EntityLabeler/CustomElements/TokenElement.tsx","components/EntityLabeler/EntityLabeler.tsx","components/EntityLabeler/index.ts","components/SliderOptions.tsx","App.tsx","constants.ts","GlobalStyles.tsx","index.tsx"],"names":["LabelMode","DebugMode","TokenType","CustomEditor","Editor","isParagraph","editor","nodes","match","n","type","firstMatchedNode","Boolean","isEntity","firstMatchNode","getEntities","at","anchor","start","focus","end","mode","map","node","path","entityNode","startTokenIndex","tokenLength","tokens","children","filter","length","tokenIndex","parent","Node","text","string","data","name","entityName","id","entityId","toggleBlockEntity","selection","Transforms","wrapNodes","undefined","select","serialize","value","join","deserialize","split","line","debounce","fn","time","timeoutId","args","clearTimeout","setTimeout","tokenizeRegex","convertEntitiesAndTextToTokenizedEditorValue","labeledText","normalizedEntities","normalizeEntities","entities","lines","lastTokenIndex","tokenizedLlines","tokenizedLine","tokenRegex","regexMatchResult","lastIndex","exec","matchedText","substring","index","nonSelectableToken","Token","isSelectable","startCharIndex","selectableToken","push","endIndex","endText","endToken","tokenizeText","labelTokens","convertToSlateValue","x","customEntities","wrapTokensWithEntities","tokenArray","sortedEntities","sort","a","b","firstEntity","initialTokens","slice","Array","from","entries","i","cet","endTokenIndex","entity","EntityPlaceholder","nextEntity","lastEntity","lastSelectedTokenIndex","endTokens","defaultValue","tokensWithEntities","paragraphElements","tokenOrEntityRow","tokensOrEntityElements","tokenOrEntity","tokenElements","token","entityElemnt","tokenElement","textElement","paragraphElement","TextSegment","styled","span","FuseMatch","props","matches","m","segmentStyles","matched","style","fuseOptions","shouldSort","includeMatches","threshold","location","distance","minMatchCharLength","keys","increment","limit","decrement","convertOptionToMatchedOption","option","highlighted","matchedStrings","original","getMatchedOptions","searchText","options","fuse","maxDisplayedOptions","trim","_","search","result","inputText","initialSegment","startIndex","reduce","segements","segementIndexWhereEntityBelongs","findIndex","seg","prevSegements","nextSegements","segementWhereEntityBelongs","prevSegementEndIndex","prevSegementText","prevSegement","nextSegementStartIndex","nextSegementText","nextSegement","newSegement","newSegements","convertMatchedTextIntoMatchedOption","item","indices","usePicker","onSelectOption","fuseRef","React","Fuse","setSearchText","highlightIndex","setHighlighIndex","matchedOptions","setMatchedOptions","current","setCollection","min","Math","max","onKeyDown","event","modifyFunction","key","shiftKey","matchedOption","onSelectHighlightedOption","stopPropagation","preventDefault","resetHighlighIndex","EntityPicker","forwardRef","forwardedRef","optionsRef","useRef","onSelectEntity","useEffect","isVisible","scrollTop","resultsElement","highlightedElement","querySelector","scrollIntoView","behavior","block","scrollHighlightedElementIntoView","wrapperStyles","position","top","left","Wrapper","ref","onDismissPicker","Input","onChange","target","onClick","onClickCreate","OptionsList","isHighlighted","OptionElement","div","input","button","unknonwnEntityElement","EntityElement","entityElement","element","EntityWrapper","attributes","EntityName","console","log","ParagraphElement","ParagraphWrapper","TokenElement","tokenStyles","Debug","TokenWrapper","getFirstTokenAncestor","rootNode","ancestors","reverse","find","isNode","editOperationTypes","selectionOperationType","initialPickerProps","EditorWrapper","renderElement","EntityLabeler","useMemo","isInline","withLabels","withReact","createEditor","useState","pickerProps","setPickerProps","closePicker","p","editorWrapperRef","entityPickerRef","debugModeValue","localStorage","getItem","debugMode","Normal","debouncedSlateValueChange","useCallback","onChangeValue","debouncedLabeledTextChange","onChangeLabeledText","debouncedSelectionChange","Range","isCollapsed","startTokenEntry","endTokenEntry","startPoint","offset","endPoint","selectionLocation","expandSelection","domSelection","globalThis","getSelection","parentElement","pickerElement","parentElementRect","getBoundingClientRect","domSelectionRect","getRangeAt","relativeSelectionLeft","halfSelectionWidth","width","centerOfSelectionLeft","halfPickerWidth","offsetWidth","relativePickerLeft","constrainedLeft","pickerSpacer","height","getPickerProps","slateValue","setSlateValue","lastLabelModeRef","lastNonNullSelectionRef","labelMode","serializedValue","EditText","newSlateValue","newLabeledText","Label","attemptedEditOperations","operations","op","editOpType","containsEditOperation","warn","o","containsSelectionOperations","customValue","some","onBlur","e","focusedElement","relatedTarget","isFocusedElementChildOfPicker","targetParent","currentElement","currentCount","document","isGivenElementChildOfOtherElement","onDragStart","onDrop","renderElementProps","randomValue","floor","random","entityPrefix","SliderOptions","highlightStyles","selectedOption","OptionWrapper","onChangeSelectedOption","Highlight","defaultLabeledText","defaultOptions","Header","header","ComponentSection","section","Column","DataSection","ValueDiv","EntityTextarea","textarea","CodeContainer","App","setLabeledText","setLabelMode","setValue","optionString","setOptionsString","labelModeOptions","uuid","rows","JSON","stringify","COLORS","highlight","hover","background","border","base","WEIGHTS","FAMILIES","GlobalStyles","createGlobalStyle","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.0af37dd8.chunk.js","sourcesContent":["export enum LabelMode {\r\n    EditText = 'EditText',\r\n    Label = 'Label'\r\n}\r\n\r\nexport enum DebugMode {\r\n    Normal = 'Normal',\r\n    Debug = 'Debug'\r\n}\r\n\r\nexport type LabeledText<T> = {\r\n    text: string\r\n    entities: LabeledEntity<T>[]\r\n}\r\n\r\nexport type EntityData = {\r\n    name: string\r\n    text: string\r\n}\r\n\r\nexport enum TokenType {\r\n    Token = \"token\",\r\n    EntityPlaceholder = \"entityPlaceholder\"\r\n}\r\n\r\nexport interface Token {\r\n    type: TokenType.Token\r\n    text: string\r\n    isSelectable: boolean\r\n    startCharIndex: number\r\n    tokenIndex: number\r\n}\r\n\r\nexport interface LabeledEntity<T> {\r\n    startTokenIndex: number\r\n    tokenLength: number\r\n    id: string\r\n    data: T\r\n}\r\n\r\nexport interface EntityPlaceholder<T> {\r\n    type: TokenType.EntityPlaceholder\r\n    entity: LabeledEntity<T>\r\n    tokens: Token[]\r\n}\r\n\r\nexport type TokenOrEntity<T> = Token | EntityPlaceholder<T>\r\n\r\nexport type Entity = {\r\n    id: string\r\n    name: string\r\n}\r\n\r\nexport type Option = {\r\n    id: string\r\n    name: string\r\n}\r\n","import { Editor, BaseText, Transforms, BaseEditor, Node, BaseSelection } from 'slate'\r\nimport { ReactEditor } from 'slate-react'\r\nimport { EntityData, LabeledText } from '.'\r\nimport { LabeledEntity, EntityPlaceholder, Token, TokenOrEntity, TokenType } from './models'\r\n\r\ntype CustomElementBase = {\r\n    children: (CustomText | CustomElement)[]\r\n}\r\n\r\ntype SlateToken = CustomElementBase & {\r\n    type: \"token\"\r\n    tokenIndex: number\r\n}\r\n\r\ntype SlateEntity = CustomElementBase & {\r\n    type: \"entity\"\r\n    entityId: string\r\n    entityName: string\r\n}\r\n\r\ntype SlateParagraph = CustomElementBase & {\r\n    type: \"paragraph\"\r\n}\r\n\r\nexport type CustomElement = SlateParagraph | SlateEntity | SlateToken\r\n\r\nexport type CustomText = BaseText & {\r\n}\r\n\r\nexport type CustomEditor = ReactEditor & BaseEditor\r\n\r\ndeclare module 'slate' {\r\n    interface CustomTypes {\r\n        Editor: CustomEditor\r\n        Element: CustomElement\r\n        Text: CustomText\r\n    }\r\n}\r\n\r\nexport const CustomEditor = {\r\n    ...Editor,\r\n\r\n    isParagraph(editor: CustomEditor) {\r\n        const [firstMatchedNode] = CustomEditor.nodes<CustomElement>(editor, {\r\n            match: n => (n as CustomElement).type === 'paragraph',\r\n        })\r\n\r\n        return Boolean(firstMatchedNode)\r\n    },\r\n    isEntity(editor: CustomEditor) {\r\n        const [firstMatchNode] = CustomEditor.nodes<CustomElement>(editor, {\r\n            match: n => (n as CustomElement).type === 'entity',\r\n        })\r\n\r\n        return Boolean(firstMatchNode)\r\n    },\r\n\r\n    getEntities(editor: CustomEditor) {\r\n        // TODO: This is only getting entities within the selection. It should get ALL entities\r\n        const entitiesNodeEntries = [...CustomEditor.nodes(editor, {\r\n            at: {\r\n                anchor: Editor.start(editor, []),\r\n                focus: Editor.end(editor, []),\r\n            },\r\n            match: n => (n as CustomElement).type === 'entity',\r\n            mode: 'all'\r\n        })]\r\n\r\n        const entities = entitiesNodeEntries\r\n            .map<LabeledEntity<EntityData>>(([node, path]) => {\r\n                // Attempt to use Slate Node API but it was more complicated\r\n                // Note.elements returns root Node?\r\n                // const tokenNodeEntries = [...Node.elements(entityNode, {\r\n                //     pass: ([n, p]) => (n as CustomElement).type === 'token'\r\n                // })]\r\n\r\n                const entityNode = node as SlateEntity\r\n\r\n                let startTokenIndex = -1\r\n                let tokenLength = 1\r\n                let tokensElements = entityNode.children\r\n                    .filter(n => (n as CustomElement).type === 'token')\r\n\r\n                const tokens = tokensElements as SlateToken[]\r\n                if (tokens.length > 0) {\r\n                    const firsToken = tokens[0]\r\n                    startTokenIndex = firsToken.tokenIndex\r\n                    tokenLength = tokens.length\r\n                }\r\n\r\n                // If you only select a single token, Transforms.wrapNodes will wrap the text\r\n                // inside the token nstead of wrapping the token\r\n                // In this case, we get the parent token and then reinsert it into the entity\r\n                else {\r\n                    const parent = Node.parent(editor, path)\r\n                    if ((parent as CustomElement).type === \"token\") {\r\n                        startTokenIndex = (parent as any).tokenIndex\r\n                    }\r\n                }\r\n\r\n                const text = Node.string(entityNode)\r\n                const entity: LabeledEntity<EntityData> = {\r\n                    data: {\r\n                        name: entityNode.entityName,\r\n                        text\r\n                    },\r\n                    id: entityNode.entityId,\r\n                    startTokenIndex,\r\n                    tokenLength,\r\n                }\r\n\r\n                return entity\r\n            })\r\n\r\n        return entities\r\n    },\r\n\r\n    toggleBlockEntity(\r\n        editor: CustomEditor,\r\n        entityId: string,\r\n        entityName: string,\r\n        selection?: BaseSelection\r\n    ) {\r\n        Transforms.wrapNodes(\r\n            editor,\r\n            { type: 'entity', entityId, entityName } as CustomElement,\r\n            {\r\n                at: selection ?? undefined\r\n            }\r\n        )\r\n\r\n        const start = Editor.start(editor, [0, 0])\r\n        Transforms.select(editor, {\r\n            anchor: start,\r\n            focus: start,\r\n        })\r\n    }\r\n}\r\n\r\nexport const withLabels = (editor: CustomEditor) => {\r\n    const { isInline } = editor\r\n\r\n    editor.isInline = (element: CustomElement) => {\r\n        switch (element.type) {\r\n            case 'entity': {\r\n                return true\r\n            }\r\n            case 'token': {\r\n                return true\r\n            }\r\n        }\r\n\r\n        return isInline(element)\r\n    }\r\n\r\n    return editor\r\n}\r\n\r\nexport const serialize = (value: CustomElement[]) => {\r\n    return (\r\n        value\r\n            // Return the string content of each paragraph in the value's children.\r\n            .map(n => Node.string(n))\r\n            // Join them all with line breaks denoting paragraphs.\r\n            .join('\\n')\r\n    )\r\n}\r\n\r\nexport const deserialize = (value: string): CustomElement[] => {\r\n    // Return a value array of children derived by splitting the string.\r\n    return value.split('\\n')\r\n        .map(line => {\r\n            return {\r\n                type: 'paragraph',\r\n                children: [{ text: line }],\r\n            }\r\n        })\r\n}\r\n\r\nexport const debounce = <T extends (...args: any[]) => any>(fn: T, time: number) => {\r\n    let timeoutId: NodeJS.Timeout\r\n\r\n    const debouncedFn = (...args: Parameters<T>) => {\r\n        if (timeoutId) {\r\n            clearTimeout(timeoutId)\r\n        }\r\n\r\n        timeoutId = setTimeout(() => {\r\n            fn(...args)\r\n        }, time)\r\n    }\r\n\r\n    return debouncedFn\r\n}\r\n\r\nexport const isGivenElementChildOfOtherElement = (e: Element, targetParent: Element): boolean => {\r\n    let currentElement = e\r\n    let currentCount = 0\r\n    let maxDomCount = 10\r\n\r\n    while (currentElement) {\r\n        if (currentElement === targetParent) {\r\n            return true\r\n        }\r\n        if (currentCount > maxDomCount) {\r\n            break\r\n        }\r\n        if (currentElement === document.parentElement) {\r\n            return false\r\n        }\r\n\r\n        currentCount += 1\r\n        currentElement = currentElement.parentElement!\r\n    }\r\n\r\n    return false\r\n}\r\n\r\n/**\r\n * Note: this is more like a negative match used to determine characters that split the string instead of\r\n * positive match would specify characters which are tokens. Only chose this because it seems like a much\r\n * simpler regex / smaller set of characters, but I imagine alternative approach would work\r\n */\r\nexport const tokenizeRegex = /[\\s.?,!]+/g\r\n\r\nexport const tokenizeText = (\r\n    text: string,\r\n    tokenRegex: RegExp,\r\n    tokenIndex = 0\r\n): [Token[], number] => {\r\n    const tokens: Token[] = []\r\n    if (text.length === 0) {\r\n        return [tokens, tokenIndex]\r\n    }\r\n\r\n    let regexMatchResult: RegExpExecArray | null = null\r\n    let lastIndex = tokenRegex.lastIndex\r\n\r\n    // tslint:disable-next-line:no-conditional-assignment\r\n    while ((regexMatchResult = tokenRegex.exec(text)) !== null) {\r\n        // The match is the token separator which is not selectable\r\n        // meaning the non matched is selectable\r\n        const matchedText = text.substring(lastIndex, regexMatchResult.index)\r\n        const nonSelectableToken: Token = {\r\n            type: TokenType.Token,\r\n            text: matchedText,\r\n            isSelectable: true,\r\n            startCharIndex: lastIndex,\r\n            tokenIndex,\r\n        }\r\n\r\n        tokenIndex += 1\r\n\r\n        const selectableToken: Token = {\r\n            type: TokenType.Token,\r\n            text: regexMatchResult[0],\r\n            isSelectable: false,\r\n            startCharIndex: regexMatchResult.index,\r\n            tokenIndex,\r\n        }\r\n\r\n        // TODO: Determine if non-selectable tokens increment the token count\r\n        tokenIndex += 1\r\n\r\n        tokens.push(...[\r\n            nonSelectableToken,\r\n            selectableToken\r\n        ])\r\n\r\n        lastIndex = tokenRegex.lastIndex\r\n    }\r\n\r\n    const endIndex = text.length\r\n    const endText = text.substring(lastIndex, endIndex)\r\n    if (endText.length > 0) {\r\n        const endToken: Token = {\r\n            type: TokenType.Token,\r\n            text: endText,\r\n            isSelectable: true,\r\n            startCharIndex: lastIndex,\r\n            tokenIndex,\r\n        }\r\n\r\n        tokens.push(endToken)\r\n    }\r\n\r\n    return [tokens, tokenIndex]\r\n}\r\n\r\n/**\r\n * Used for conversion of text and custom entities. For proper usage within extractor editor we need to tokenize the text.\r\n * This is what makes it different from the below method which doesn't need to be tokenized.\r\n */\r\nexport const convertEntitiesAndTextToTokenizedEditorValue = (\r\n    labeledText: LabeledText<EntityData>\r\n) => {\r\n    const normalizedEntities = normalizeEntities(labeledText.entities)\r\n    const lines = labeledText.text.split('\\n')\r\n        // Remove blank lines\r\n        .filter(line => line.length > 0)\r\n\r\n    // Currently tokens are set per line meaning each line resets index\r\n    // Store last index and incement to have total index\r\n    let lastTokenIndex = 0\r\n    const tokenizedLlines = lines\r\n        .map(line => {\r\n            let tokenizedLine: Token[]\r\n            [tokenizedLine, lastTokenIndex] = tokenizeText(line, tokenizeRegex, lastTokenIndex)\r\n            const labeledTokens = labelTokens(tokenizedLine, normalizedEntities)\r\n            return labeledTokens\r\n        })\r\n\r\n    return convertToSlateValue(tokenizedLlines)\r\n}\r\n\r\nexport const normalizeEntities = <T>(x: T): T => { return x }\r\n\r\nexport const labelTokens = <T>(tokens: Token[], customEntities: LabeledEntity<T>[]): TokenOrEntity<T>[] => {\r\n    return wrapTokensWithEntities(tokens, customEntities)\r\n}\r\n\r\n/**\r\n * Similar to findIndex, but finds last index by iterating array items from end/right instead of start/left\r\n * @param xs Array\r\n * @param f Predicate function\r\n */\r\nexport const findLastIndex = <T>(xs: T[], f: (x: T) => boolean): number => {\r\n    // tslint:disable-next-line:no-increment-decrement\r\n    for (let i = xs.length - 1; i >= 0; i--) {\r\n        if (f(xs[i])) {\r\n            return i\r\n        }\r\n    }\r\n\r\n    return -1\r\n}\r\n\r\n/**\r\n * Given tokens and custom entities associated with tokens, replace tokens with entities placeholders\r\n * These entity placeholders eventually get converted to slate inline segments\r\n *\r\n * Simplified visual\r\n * [token0, token1, token2, token3, token4, token5, token6], [{ text: token6, startTokenIndex: 1, tokenLength: 3 }]\r\n * [token0, [token1, token2, token3], token4, token5, token6]\r\n *\r\n * @param tokens Array of Tokens\r\n * @param entities Array of Entities with Token Indices\r\n */\r\nexport const wrapTokensWithEntities = <T>(tokens: Token[], entities: LabeledEntity<T>[]): TokenOrEntity<T>[] => {\r\n    // If there are no entities than no work to do, return tokens\r\n    if (entities.length === 0) {\r\n        return tokens\r\n    }\r\n\r\n    const tokenArray: TokenOrEntity<T>[] = []\r\n    const sortedEntities = [...entities].sort((a, b) => a.startTokenIndex - b.startTokenIndex)\r\n\r\n    // Include all non labeled tokens before first entity\r\n    const firstEntity = sortedEntities[0]\r\n    const initialTokens = [...tokens.slice(0, firstEntity.startTokenIndex)]\r\n    tokenArray.push(...initialTokens)\r\n\r\n    // This requires entities to be non overlapping since each entity contains other tokens\r\n    for (const [i, cet] of Array.from(sortedEntities.entries())) {\r\n        // push labeled tokens\r\n        const endTokenIndex = cet.startTokenIndex + cet.tokenLength\r\n        const entity: EntityPlaceholder<T> = {\r\n            type: TokenType.EntityPlaceholder,\r\n            entity: cet,\r\n            tokens: tokens.slice(cet.startTokenIndex, endTokenIndex)\r\n        }\r\n\r\n        tokenArray.push(entity)\r\n\r\n        // If not at the last entity push non labeled tokens in between this and next entity\r\n        if (i !== sortedEntities.length - 1) {\r\n            const nextEntity = sortedEntities[i + 1]\r\n            tokenArray.push(...tokens.slice(endTokenIndex, nextEntity.startTokenIndex))\r\n        }\r\n    }\r\n\r\n    // Include all non labeled tokens after last entity\r\n    const lastEntity = sortedEntities[sortedEntities.length - 1]\r\n    const lastSelectedTokenIndex = lastEntity.startTokenIndex + lastEntity.tokenLength\r\n    const endTokens = tokens.slice(lastSelectedTokenIndex)\r\n    tokenArray.push(...endTokens)\r\n\r\n    return tokenArray\r\n}\r\n\r\nexport const defaultValue: CustomElement[] = [\r\n    {\r\n        type: 'paragraph',\r\n        children: [\r\n            {\r\n                text: ''\r\n            },\r\n        ],\r\n    }\r\n]\r\n\r\nexport const convertToSlateValue = (tokensWithEntities: TokenOrEntity<EntityData>[][]): CustomElement[] => {\r\n    // If there are no tokens, just return empty text node to ensure valid SlateValue object\r\n    // In other words non-void parent nodes must have a child.\r\n    if (tokensWithEntities.length === 0) {\r\n        return defaultValue\r\n    }\r\n\r\n    const paragraphElements: CustomElement[] = []\r\n\r\n    for (const tokenOrEntityRow of tokensWithEntities) {\r\n\r\n        const tokensOrEntityElements: (CustomText | CustomElement)[] = []\r\n        for (const tokenOrEntity of tokenOrEntityRow) {\r\n            if (tokenOrEntity.type === TokenType.EntityPlaceholder) {\r\n                const tokenElements = tokenOrEntity.tokens\r\n                    .map<CustomElement>(token => {\r\n                        return {\r\n                            type: \"token\",\r\n                            tokenIndex: token.tokenIndex,\r\n                            children: [\r\n                                {\r\n                                    text: token.text\r\n                                }\r\n                            ]\r\n                        }\r\n                    })\r\n\r\n                const entityElemnt: CustomElement = {\r\n                    type: \"entity\",\r\n                    entityId: tokenOrEntity.entity.id,\r\n                    entityName: tokenOrEntity.entity.data.name,\r\n                    children: tokenElements\r\n                }\r\n\r\n                tokensOrEntityElements.push(entityElemnt)\r\n            }\r\n            else {\r\n                if (tokenOrEntity.isSelectable) {\r\n                    const tokenElement: CustomElement = {\r\n                        type: \"token\",\r\n                        tokenIndex: tokenOrEntity.tokenIndex,\r\n                        children: [\r\n                            {\r\n                                text: tokenOrEntity.text\r\n                            }\r\n                        ]\r\n                    }\r\n                    tokensOrEntityElements.push(tokenElement)\r\n                }\r\n                else {\r\n                    const textElement: CustomText = {\r\n                        text: tokenOrEntity.text\r\n                    }\r\n\r\n                    tokensOrEntityElements.push(textElement)\r\n                }\r\n            }\r\n        }\r\n\r\n        const paragraphElement: CustomElement = {\r\n            type: 'paragraph',\r\n            children: tokensOrEntityElements\r\n        }\r\n\r\n        paragraphElements.push(paragraphElement)\r\n    }\r\n\r\n    return paragraphElements\r\n}\r\n\r\n/**\r\n * Compare every entity to every other entity. If any have overlapping indices then log warning.\r\n *\r\n * @param customEntities List of custom entities\r\n */\r\nexport const warnAboutOverlappingEntities = (customEntities: LabeledEntity<object>[]): boolean => {\r\n    return customEntities.some((entity, i) => {\r\n        return customEntities\r\n            .slice(i + 1)\r\n            .some((otherEntity, _, es) => {\r\n                // Other entity overlaps start index of current entity\r\n                //  [ other entity ]\r\n                //            [ entity ]\r\n                const entityEndTokenIndex = entity.startTokenIndex + entity.tokenLength\r\n                const otherEntityEndTokenIndex = otherEntity.startTokenIndex + otherEntity.tokenLength\r\n                const overlapStartIndex = (otherEntity.startTokenIndex <= entity.startTokenIndex\r\n                    && otherEntityEndTokenIndex >= entity.startTokenIndex)\r\n\r\n                // Other entity overlaps end index of current entity\r\n                //    [ other entity ]\r\n                // [entity]\r\n                const overlapEndIndex = (otherEntity.startTokenIndex <= entityEndTokenIndex\r\n                    && otherEntityEndTokenIndex >= entityEndTokenIndex)\r\n\r\n                const overlap = overlapStartIndex || overlapEndIndex\r\n\r\n                if (overlap) {\r\n                    console.warn(`Custom entities have overlap. Overlapping entities will be discarded to allow proper rendering in UI but this is a bug.`, customEntities)\r\n                }\r\n\r\n                return overlap\r\n            })\r\n    })\r\n}\r\n","/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport React from 'react'\r\nimport styled from 'styled-components'\r\nimport { MatchedString } from './models'\r\n\r\ntype Props = {\r\n    matches: MatchedString[]\r\n}\r\n\r\n/**\r\n * Display Fuse.io search match with characters from search input having custom style such as highlight or bold\r\n */\r\nconst FuseMatch: React.FC<Props> = props => {\r\n    return <span>\r\n        {props.matches\r\n            .map((m, i) => {\r\n                const segmentStyles = { '--weight': m.matched ? 'bold' : 'normal' } as React.CSSProperties\r\n                return (\r\n                    <TextSegment style={segmentStyles} key={i}>\r\n                        {m.text}\r\n                    </TextSegment>\r\n                )\r\n            })}\r\n    </span>\r\n}\r\n\r\nconst TextSegment = styled.span`\r\n    font-weight: var(--weight);\r\n`\r\n\r\nexport default FuseMatch","/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nimport * as React from 'react'\r\nimport Fuse from 'fuse.js'\r\nimport { convertMatchedTextIntoMatchedOption, MatchedOption } from '../FuseMatch'\r\nimport { Option } from './models'\r\n\r\n/**\r\n * See http://fusejs.io/ for information about options meaning and configuration\r\n */\r\nconst fuseOptions: Fuse.IFuseOptions<Option> = {\r\n    shouldSort: true,\r\n    includeMatches: true,\r\n    threshold: 0.4,\r\n    location: 0,\r\n    distance: 10,\r\n    // maxPatternLength: 32,\r\n    minMatchCharLength: 1,\r\n    keys: [\r\n        \"name\"\r\n    ]\r\n}\r\n\r\ntype IndexFunction = (x: number, limit: number) => number\r\nconst id: IndexFunction = (x: number) => x\r\nconst increment: IndexFunction = (x: number, limit: number) => (x + 1) > limit ? 0 : x + 1\r\nconst decrement: IndexFunction = (x: number, limit: number) => (x - 1) < 0 ? limit : x - 1\r\n\r\nconst convertOptionToMatchedOption = (option: Option): MatchedOption<Option> => {\r\n    return {\r\n        highlighted: false,\r\n        matchedStrings: [{ text: option.name, matched: false }],\r\n        original: option\r\n    }\r\n}\r\n\r\nconst getMatchedOptions = (\r\n    searchText: string,\r\n    options: Option[],\r\n    fuse: Fuse<Option>,\r\n    maxDisplayedOptions: number\r\n): MatchedOption<Option>[] => {\r\n    return searchText.trim().length === 0\r\n        ? options\r\n            .filter((_, i) => i < maxDisplayedOptions)\r\n            .map(convertOptionToMatchedOption)\r\n        : fuse.search(searchText)\r\n            .filter((_, i) => i < maxDisplayedOptions)\r\n            .map(result => convertMatchedTextIntoMatchedOption(result.item.name, result.matches?.[0].indices ?? [], result.item))\r\n}\r\n\r\nexport const usePicker = (\r\n    options: Option[],\r\n    maxDisplayedOptions: number,\r\n    onSelectOption: (option: Option) => void,\r\n) => {\r\n    const fuseRef = React.useRef(new Fuse(options, fuseOptions))\r\n    const [searchText, setSearchText] = React.useState('')\r\n    const [highlightIndex, setHighlighIndex] = React.useState(0)\r\n    const [matchedOptions, setMatchedOptions] = React.useState<MatchedOption<Option>[]>([])\r\n\r\n    const resetHighlighIndex = () => setHighlighIndex(0)\r\n    const onSelectHighlightedOption = () => {\r\n        const matchedOption = matchedOptions[highlightIndex]\r\n        if (matchedOption) {\r\n            onSelectOption(matchedOption.original)\r\n        }\r\n    }\r\n\r\n    React.useEffect(() => {\r\n        fuseRef.current.setCollection(options)\r\n        const matchedOptions = getMatchedOptions(searchText, options, fuseRef.current, maxDisplayedOptions)\r\n        setMatchedOptions(matchedOptions)\r\n    }, [options.length, searchText, maxDisplayedOptions])\r\n\r\n    // Ensure highlight index is within bounds\r\n    React.useEffect(() => {\r\n        // Decrease highlight index to last item when options list shrinks due to search filter\r\n        let min = highlightIndex > (matchedOptions.length - 1)\r\n            ? (matchedOptions.length - 1)\r\n            : highlightIndex\r\n\r\n        // Don't allow an index less than 0 (if options length is 0)\r\n        min = Math.max(0, min)\r\n        setHighlighIndex(min)\r\n    }, [matchedOptions.length, highlightIndex])\r\n\r\n    const onKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\r\n        let modifyFunction: IndexFunction = id\r\n        switch (event.key) {\r\n            case 'ArrowUp': {\r\n                modifyFunction = decrement\r\n                break\r\n            }\r\n            case 'ArrowDown':\r\n                modifyFunction = increment\r\n                break\r\n            // TODO: Should we allow tab completion?\r\n            // case 'Tab':\r\n            case 'Enter':\r\n                // Only simulate completion on 'forward' tab\r\n                if (event.shiftKey) {\r\n                    return\r\n                }\r\n\r\n                onSelectHighlightedOption()\r\n                event.stopPropagation()\r\n                event.preventDefault()\r\n                break\r\n            default:\r\n        }\r\n\r\n        setHighlighIndex(modifyFunction(highlightIndex, matchedOptions.length - 1))\r\n    }\r\n\r\n    return {\r\n        searchText,\r\n        setSearchText,\r\n        onKeyDown,\r\n        matchedOptions,\r\n        highlightIndex,\r\n        resetHighlighIndex,\r\n    }\r\n}","/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport * as models from './models'\r\n\r\n/**\r\n * Convert Fuse.io search results into match options which are renderable by React\r\n * Works similarly to the function in ExtractorEditor to segement a string by start and end indicies from label entities\r\n * Except we're segmenting the start and end indicies from the Fuse result\r\n *\r\n * Input:\r\n *  012345678901234\r\n * 'I am some text', [[5,9] [10,14]]\r\n *\r\n * Segments:\r\n * 'I am some text'\r\n * 'I am ','some text'\r\n * 'I am ','some',' text'\r\n * 'I am ','some',' ','text'\r\n *\r\n * Output:\r\n * ['I am ', 'some', ' ', 'text']\r\n *\r\n * @param inputText text string\r\n * @param matches List of [startIndex, endIndex] pairs\r\n * @param original Unmodified original result\r\n */\r\nexport const convertMatchedTextIntoMatchedOption = <T>(inputText: string, matches: ReadonlyArray<[number, number]>, original: T): models.MatchedOption<T> => {\r\n    const initialSegment: models.ISegement = {\r\n        text: inputText,\r\n        startIndex: 0,\r\n        endIndex: inputText.length,\r\n        data: {\r\n            matched: false\r\n        }\r\n    }\r\n\r\n    const matchedSegments = matches.reduce<models.ISegement[]>((segements, [startIndex, originalEndIndex]) => {\r\n        // TODO: For some reason the Fuse.io library returns the end index before the last character instead of after\r\n        // I opened issue here for explanation: https://github.com/krisk/Fuse/issues/212\r\n        const endIndex = originalEndIndex + 1\r\n        const segementIndexWhereEntityBelongs = segements.findIndex(seg => seg.startIndex <= startIndex && endIndex <= seg.endIndex)\r\n        const prevSegements = segements.slice(0, segementIndexWhereEntityBelongs)\r\n        const nextSegements = segements.slice(segementIndexWhereEntityBelongs + 1, segements.length)\r\n        const segementWhereEntityBelongs = segements[segementIndexWhereEntityBelongs]\r\n\r\n        const prevSegementEndIndex = startIndex - segementWhereEntityBelongs.startIndex\r\n        const prevSegementText = segementWhereEntityBelongs.text.substring(0, prevSegementEndIndex)\r\n        const prevSegement: models.ISegement = {\r\n            ...segementWhereEntityBelongs,\r\n            text: prevSegementText,\r\n            endIndex: startIndex,\r\n        }\r\n\r\n        const nextSegementStartIndex = endIndex - segementWhereEntityBelongs.startIndex\r\n        const nextSegementText = segementWhereEntityBelongs.text.substring(nextSegementStartIndex, segementWhereEntityBelongs.text.length)\r\n        const nextSegement: models.ISegement = {\r\n            ...segementWhereEntityBelongs,\r\n            text: nextSegementText,\r\n            startIndex: endIndex,\r\n        }\r\n\r\n        const newSegement: models.ISegement = {\r\n            text: segementWhereEntityBelongs.text.substring(prevSegementEndIndex, nextSegementStartIndex),\r\n            startIndex: startIndex,\r\n            endIndex: endIndex,\r\n            data: {\r\n                matched: true\r\n            }\r\n        }\r\n\r\n        const newSegements = []\r\n        if (prevSegement.startIndex !== prevSegement.endIndex) {\r\n            newSegements.push(prevSegement)\r\n        }\r\n\r\n        if (newSegement.startIndex !== newSegement.endIndex) {\r\n            newSegements.push(newSegement)\r\n        }\r\n\r\n        if (nextSegement.startIndex !== nextSegement.endIndex) {\r\n            newSegements.push(nextSegement)\r\n        }\r\n\r\n        return [...prevSegements, ...newSegements, ...nextSegements]\r\n    }, [\r\n        initialSegment\r\n    ])\r\n\r\n    const matchedStrings = matchedSegments\r\n        .map(({ text, data }) => ({\r\n            text,\r\n            matched: data.matched\r\n        }))\r\n\r\n    return {\r\n        highlighted: false,\r\n        original,\r\n        matchedStrings\r\n    }\r\n}","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport { Entity } from './models'\r\nimport { FuseMatch } from '../FuseMatch'\r\nimport { usePicker } from './usePicker'\r\nimport { Option } from './models'\r\n\r\ntype Position = {\r\n    top: number\r\n    left: number\r\n}\r\n\r\nexport type PickerProps = {\r\n    isVisible: boolean\r\n    position: Position\r\n}\r\n\r\ntype Props = PickerProps & {\r\n    entities: Entity[]\r\n    onClickCreate: () => void\r\n    onSelectEntity: (entity: Entity) => void\r\n    onDismissPicker: () => void\r\n}\r\n\r\n// This works because options and entity type are the same\r\nconst convertOptionToEntity = (option: Option): Entity => option\r\n\r\nconst scrollHighlightedElementIntoView = (resultsElement: HTMLDivElement) => {\r\n    const highlightedElement = resultsElement\r\n        ? resultsElement.querySelector('[data-is-highlighted=\"true\"]') as HTMLDivElement\r\n        : null\r\n\r\n    if (highlightedElement) {\r\n        highlightedElement.scrollIntoView({\r\n            behavior: 'smooth',\r\n            block: \"nearest\"\r\n        })\r\n    }\r\n}\r\n\r\nexport const EntityPicker = React.forwardRef<HTMLDivElement, Props>((props, forwardedRef) => {\r\n    const optionsRef = React.useRef<HTMLDivElement>(null)\r\n\r\n    const onSelectOption = (option: Option) => {\r\n        const entity = convertOptionToEntity(option)\r\n        props.onSelectEntity(entity)\r\n    }\r\n\r\n    React.useEffect(() => {\r\n        // Reset options list scroll\r\n        if (props.isVisible && optionsRef.current) {\r\n            optionsRef.current.scrollTop = 0\r\n        }\r\n    }, [props.isVisible])\r\n\r\n    const { searchText, setSearchText, onKeyDown, matchedOptions, highlightIndex, resetHighlighIndex } = usePicker(\r\n        props.entities,\r\n        100,\r\n        onSelectOption,\r\n    )\r\n\r\n    React.useEffect(() => {\r\n        if (optionsRef.current) {\r\n            scrollHighlightedElementIntoView(optionsRef.current)\r\n        }\r\n    }, [highlightIndex, optionsRef.current])\r\n\r\n    const onPickerKeyDown: React.KeyboardEventHandler<HTMLDivElement> = event => {\r\n        switch (event.key) {\r\n            case 'Escape':\r\n                props.onDismissPicker()\r\n                event.preventDefault()\r\n                return\r\n        }\r\n\r\n        onKeyDown(event)\r\n    }\r\n\r\n    const onChangeSearchInput: React.ChangeEventHandler<HTMLInputElement> = event => {\r\n        setSearchText(event.target.value)\r\n    }\r\n\r\n    React.useEffect(() => {\r\n        if (props.isVisible === false) {\r\n            setSearchText('')\r\n            resetHighlighIndex()\r\n        }\r\n    }, [props.isVisible, setSearchText, resetHighlighIndex])\r\n\r\n    const wrapperStyles = {\r\n        '--opacity': props.isVisible ? '1' : '0',\r\n        '--scale': props.isVisible ? '1' : '0',\r\n        '--top': `${props.position.top}px`,\r\n        '--left': `${props.position.left}px`,\r\n    } as React.CSSProperties\r\n\r\n    return (\r\n        <Wrapper\r\n            ref={forwardedRef}\r\n            isVisible={props.isVisible}\r\n            position={props.position}\r\n            style={wrapperStyles}\r\n            onKeyDown={onPickerKeyDown}\r\n        >\r\n            <Input type=\"text\" value={searchText} onChange={onChangeSearchInput} />\r\n            <button onClick={props.onClickCreate}>Create Entity</button>\r\n            <OptionsList ref={optionsRef}>\r\n                {matchedOptions.map((matchedOption, i) => {\r\n                    const isHighlighted = highlightIndex === i\r\n                    return (\r\n                        <OptionElement\r\n                            key={i}\r\n                            onClick={() => onSelectOption(matchedOption.original)}\r\n                            highlighted={isHighlighted}\r\n                            data-is-highlighted={isHighlighted}\r\n                        >\r\n                            <FuseMatch matches={matchedOption.matchedStrings} />\r\n                        </OptionElement>\r\n                    )\r\n                })}\r\n            </OptionsList>\r\n        </Wrapper>\r\n    )\r\n})\r\n\r\nconst Wrapper = styled.div<PickerProps>`\r\n    display: grid;\r\n    grid-template-rows: min-content min-content 1fr;\r\n    gap: 0.25em;\r\n\r\n    color: black;\r\n    font-size: 1rem;\r\n    background: white;\r\n    border: 1px solid var(--color-neutralTertiary);\r\n    border-radius: 4px;\r\n    box-shadow: 0 1px 10px rgba(0, 0, 0, 0.3);\r\n    min-width: 200px;\r\n    max-width: 300px;\r\n    max-height: 200px;\r\n    padding: 0.25em;\r\n    z-index: 1;\r\n\r\n    opacity: var(--opacity);\r\n    transform: scale(var(--scale));\r\n    transform-origin: 50% 10px;\r\n    transition: transform 0.2s cubic-bezier(.3,1.2,.2,1),\r\n                top 0.2s ease-in-out,\r\n                left 0.2s ease-in-out,\r\n                opacity 0.7s;\r\n\r\n    will-change: transform;\r\n\r\n    position: absolute;\r\n    top: var(--top);\r\n    left: var(--left);\r\n    overscroll-behavior: contain;\r\n`\r\n\r\nconst Input = styled.input`\r\n    border: 1px solid var(--color-gray-500);\r\n    padding: 0.25em;\r\n\r\n    :focus {\r\n        border-color: var(--color-gray-300);\r\n    }\r\n`\r\n\r\nconst OptionsList = styled.div`\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow: auto;\r\n`\r\n\r\nconst OptionElement = styled.button<{ highlighted: boolean }>`\r\n    padding: 0.25rem;\r\n    cursor: pointer;\r\n    border: none;\r\n    border-radius: 3px;\r\n    transition: background 0.6s ease-out;\r\n\r\n    &[data-is-highlighted=\"true\"],\r\n    :focus {\r\n        transition: background 0.3s ease-in;\r\n        background: var(--color-picker-highlighted);\r\n    }\r\n\r\n    :hover:not([data-is-highlighted=\"true\"]) {\r\n        background: var(--color-picker-hover);\r\n        outline: none;\r\n    }\r\n`","import { RenderElementProps } from \"slate-react\"\r\nimport styled from \"styled-components\"\r\nimport { CustomElement } from \"../utils\"\r\nimport { DebugMode } from \"../models\"\r\n\r\ntype Props = RenderElementProps & {\r\n    mode: DebugMode\r\n}\r\n\r\nconst unknonwnEntityElement: CustomElement = {\r\n    children: [],\r\n    type: \"entity\",\r\n    entityId: 'default-entity-id',\r\n    entityName: 'Unknown Name'\r\n}\r\n\r\nexport const EntityElement: React.FC<Props> = props => {\r\n    const entityElement = props.element.type === 'entity'\r\n        ? props.element\r\n        // Should never happen, but will give visual indicator if used by showing \"unknown\" as name\r\n        : unknonwnEntityElement\r\n\r\n    const onClickName: React.MouseEventHandler<HTMLDivElement> = event => {\r\n        console.log('click', event)\r\n        event.preventDefault()\r\n        event.stopPropagation()\r\n        return false\r\n    }\r\n\r\n    return (\r\n        <EntityWrapper\r\n            {...props.attributes}\r\n            data-is-entity={true}\r\n        >\r\n            {props.children}\r\n            <EntityName onClick={onClickName} data-name={entityElement.entityName} />\r\n        </EntityWrapper>\r\n    )\r\n}\r\n\r\nconst EntityWrapper = styled.div`\r\n    position: relative;\r\n    display: inline-block;\r\n    border-radius: 3px;\r\n\r\n    background: var(--color-entities-background);\r\n    margin: -1px;\r\n    border 1px solid var(--color-entities-border);\r\n`\r\n\r\n// Use pseudo content to prevent selection\r\n// Technique described here\r\n// https://danoc.me/blog/css-prevent-copy/#an-elegant-solution-using-pseudo-elements\r\nconst EntityName = styled.div`\r\n    position: absolute;\r\n    top: calc(-100% + 1rem);\r\n    white-space: nowrap;\r\n    font-size: 1.1rem;\r\n    color: var(--color-entities-name);\r\n    max-width: 100%;\r\n    overflow: hidden;\r\n\r\n    ::before {\r\n        content: attr(data-name);\r\n    }\r\n\r\n    :hover {\r\n        max-width: unset;\r\n        overflow: unset;\r\n        background: var(--color-gray-900);\r\n        border-right: 4px solid var(--color-gray-900);\r\n        color: var(--color-entities-name-highlight);\r\n        z-index: 2;\r\n    }\r\n`","import { RenderElementProps } from \"slate-react\"\r\nimport styled from \"styled-components\"\r\n\r\ntype Props = RenderElementProps\r\n\r\nexport const ParagraphElement: React.FC<Props> = props => {\r\n    return (\r\n        <ParagraphWrapper\r\n            {...props.attributes}\r\n            data-is-paragraph={true}\r\n        >\r\n            {props.children}\r\n        </ParagraphWrapper>\r\n    )\r\n}\r\n\r\nconst ParagraphWrapper = styled.div`\r\n    padding: 0.9em 0 0 0;\r\n`\r\n","import { RenderElementProps } from \"slate-react\"\r\nimport styled from \"styled-components\"\r\nimport { DebugMode } from \"../models\"\r\n\r\ntype Props = RenderElementProps & {\r\n    mode: DebugMode\r\n}\r\n\r\nexport const TokenElement: React.FC<Props> = props => {\r\n    const tokenStyles = {\r\n        '--background-color': props.mode === DebugMode.Debug ? `var(--color-token-base)` : 'none',\r\n        '--margin': props.mode === DebugMode.Debug ? `-1px` : 'unset',\r\n        '--border': props.mode === DebugMode.Debug ? `1px solid var(--color-token-base)` : 'unset',\r\n    } as React.CSSProperties\r\n\r\n    return (\r\n        <TokenWrapper\r\n            {...props.attributes}\r\n            data-is-token={true}\r\n            mode={props.mode}\r\n            style={tokenStyles}\r\n        >\r\n            {props.children}\r\n        </TokenWrapper>\r\n    )\r\n}\r\n\r\nconst TokenWrapper = styled.div<{ mode: DebugMode }>`\r\n    display: inline-block;\r\n    border-radius: 3px;\r\n    background: var(--background-color);\r\n    margin: var(--margin);\r\n    border: var(--border);\r\n`","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport { Ancestor, BaseSelection, createEditor, Node, NodeEntry, Path, Point, Range, Transforms } from 'slate'\r\nimport { Slate, Editable, withReact, DefaultElement, RenderElementProps } from 'slate-react'\r\n\r\nimport { convertEntitiesAndTextToTokenizedEditorValue, isGivenElementChildOfOtherElement, CustomEditor, CustomText, deserialize, debounce, CustomElement, serialize, withLabels } from './utils'\r\nimport { DebugMode, LabeledEntity, LabelMode, EntityData, Entity } from './models'\r\nimport { EntityPicker, PickerProps } from './EntityPicker'\r\nimport { TokenElement, EntityElement, ParagraphElement } from './CustomElements'\r\nimport { LabeledText } from '.'\r\n\r\nconst getFirstTokenAncestor = (rootNode: Node, path: Path) => {\r\n    const firstTokenAncestor = [...Node.ancestors(rootNode, path, { reverse: true })]\r\n        .find(([node]) => Node.isNode(node) && (node as CustomElement).type === 'token')\r\n\r\n    return firstTokenAncestor\r\n}\r\n\r\nconst editOperationTypes = [\r\n    'remove_text',\r\n    'insert_text',\r\n]\r\n\r\n// Need these operations to use Transforms.wrapNodes\r\nconst externalOperationsType = [\r\n    'remove_node',\r\n    'insert_node',\r\n]\r\n\r\nconst selectionOperationType = 'set_selection'\r\n\r\nconst initialPickerProps: PickerProps = {\r\n    isVisible: false,\r\n    position: {\r\n        top: 0,\r\n        left: 0,\r\n    }\r\n}\r\n\r\ntype Props = {\r\n    labelMode: LabelMode\r\n    labeledText: LabeledText<EntityData>,\r\n    entities: Entity[]\r\n    onChangeValue: (value: CustomElement[]) => void\r\n    onChangeLabeledText: (labeledText: LabeledText<EntityData>) => void\r\n}\r\n\r\nconst entityLabelerDebugKey = 'entity-labeler'\r\n\r\nconst EntityLabeler: React.FC<Props> = props => {\r\n    const editor = React.useMemo(() => withLabels(withReact(createEditor())), [])\r\n    const [pickerProps, setPickerProps] = React.useState<PickerProps>(initialPickerProps)\r\n    const closePicker = () => {\r\n        setPickerProps(p => ({\r\n            ...p,\r\n            isVisible: false\r\n        }))\r\n    }\r\n    const editorWrapperRef = React.useRef<HTMLDivElement>(null)\r\n    const entityPickerRef = React.useRef<HTMLDivElement>(null)\r\n    const debugModeValue = localStorage.getItem(entityLabelerDebugKey)\r\n    const debugMode = typeof debugModeValue === 'string' && debugModeValue !== null\r\n        ? DebugMode.Debug\r\n        : DebugMode.Normal\r\n\r\n    const debouncedSlateValueChange = React.useCallback(debounce(props.onChangeValue, 300), [props.onChangeValue])\r\n    const debouncedLabeledTextChange = React.useCallback(debounce(props.onChangeLabeledText, 300), [props.onChangeLabeledText])\r\n    const debouncedSelectionChange = React.useCallback(debounce(() => {\r\n        if (!editor.selection) {\r\n            return\r\n        }\r\n\r\n        if (Range.isCollapsed(editor.selection)) {\r\n            closePicker()\r\n            return\r\n        }\r\n\r\n        const start = Range.start(editor.selection)\r\n        const end = Range.end(editor.selection)\r\n\r\n        let startTokenEntry = getFirstTokenAncestor(editor, start.path)\r\n        let endTokenEntry = getFirstTokenAncestor(editor, end.path)\r\n\r\n        // If either entry is undefined, set to other value\r\n        startTokenEntry = startTokenEntry ?? endTokenEntry\r\n        endTokenEntry = endTokenEntry ?? startTokenEntry\r\n\r\n        // If we found a start and end token from selection search, expand selection to those token boundaries\r\n        if (startTokenEntry && endTokenEntry) {\r\n            expandSelection(startTokenEntry, endTokenEntry, editor)\r\n\r\n            // Get picker props\r\n            if (editorWrapperRef.current && entityPickerRef.current) {\r\n                const domSelection = globalThis.getSelection()\r\n                if (domSelection) {\r\n                    const pickerProps = getPickerProps(\r\n                        editorWrapperRef.current,\r\n                        entityPickerRef.current,\r\n                        domSelection\r\n                    )\r\n\r\n                    setPickerProps(pickerProps)\r\n                }\r\n            }\r\n        }\r\n\r\n    }, 300), [])\r\n\r\n    const [slateValue, setSlateValue] = React.useState<CustomElement[]>(deserialize(props.labeledText.text))\r\n    const lastLabelModeRef = React.useRef<LabelMode | undefined>()\r\n    const lastNonNullSelectionRef = React.useRef<BaseSelection>(null)\r\n\r\n    React.useEffect(() => {\r\n        debouncedSlateValueChange(slateValue)\r\n    }, [slateValue, debouncedSlateValueChange])\r\n\r\n    React.useEffect(() => {\r\n        // If label mode is set and has changed\r\n        if (lastLabelModeRef.current && lastLabelModeRef.current !== props.labelMode) {\r\n            const serializedValue = serialize(slateValue)\r\n\r\n            switch (props.labelMode) {\r\n                case LabelMode.EditText: {\r\n                    // Get text from value by serializing and deserializing\r\n                    const newSlateValue = deserialize(serializedValue)\r\n                    setSlateValue(newSlateValue)\r\n\r\n                    // Get new lableed text value with reset entities\r\n                    const newLabeledText: LabeledText<EntityData> = {\r\n                        text: serializedValue,\r\n                        entities: []\r\n                    }\r\n\r\n                    props.onChangeLabeledText(newLabeledText)\r\n\r\n                    // Reset picker\r\n                    closePicker()\r\n                    break\r\n                }\r\n                case LabelMode.Label: {\r\n                    const slateValue = convertEntitiesAndTextToTokenizedEditorValue(props.labeledText)\r\n                    setSlateValue(slateValue)\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n        lastLabelModeRef.current = props.labelMode\r\n    }, [props.labelMode])\r\n\r\n    const onBlurSlateEditorWrapper: React.FocusEventHandler<HTMLDivElement> = (e) => {\r\n        const focusedElement = e.relatedTarget as Element\r\n        if (entityPickerRef.current) {\r\n            const isFocusedElementChildOfPicker = isGivenElementChildOfOtherElement(focusedElement, entityPickerRef.current)\r\n\r\n            if (isFocusedElementChildOfPicker) {\r\n                return\r\n            }\r\n        }\r\n\r\n        closePicker()\r\n    }\r\n\r\n    const onPickerCreateEntity = () => {\r\n        // TODO: Likely open more complicated entity creation wizard\r\n        // But for now just create random entity\r\n        const randomValue = Math.floor(Math.random() * 100)\r\n        const entityPrefix = `entityName-${randomValue}`\r\n        const mockEntity: Entity = {\r\n            id: entityPrefix,\r\n            name: entityPrefix\r\n        }\r\n\r\n        onSelectEntity(mockEntity)\r\n    }\r\n\r\n    const onSelectEntity = (entity: Entity) => {\r\n        const selection = editor.selection ?? lastNonNullSelectionRef.current\r\n        if (selection && Range.isCollapsed(selection)) {\r\n            return\r\n        }\r\n\r\n        // Create entity around selection\r\n        CustomEditor.toggleBlockEntity(editor, entity.id, entity.name, selection)\r\n\r\n        // Reset last selection\r\n        lastNonNullSelectionRef.current = null\r\n\r\n        closePicker()\r\n    }\r\n\r\n    const onEditableKeyDown: React.KeyboardEventHandler<HTMLDivElement> = event => {\r\n        if (props.labelMode === LabelMode.Label) {\r\n            // console.log({ key: event.key })\r\n            switch (event.key) {\r\n                case 'Escape':\r\n                    closePicker()\r\n                    event.preventDefault()\r\n                    break\r\n                case ' ':\r\n                case 'Enter':\r\n                case 'Backspace':\r\n                case 'Delete':\r\n                    event.preventDefault()\r\n                    event.stopPropagation()\r\n            }\r\n        }\r\n    }\r\n\r\n    const onEditableDrop: React.DragEventHandler<HTMLDivElement> = event => {\r\n        return false\r\n    }\r\n\r\n    return (\r\n        <Slate\r\n            editor={editor}\r\n            value={slateValue}\r\n            onChange={value => {\r\n                // If selection is defined, save selection for use after it is removed due to blur\r\n                if (editor.selection !== null) {\r\n                    lastNonNullSelectionRef.current = editor.selection\r\n                }\r\n\r\n                const attemptedEditOperations = editor.operations.filter(op => {\r\n                    return editOperationTypes.find(editOpType => editOpType === op.type)\r\n                })\r\n\r\n                const containsEditOperation = attemptedEditOperations.length > 0\r\n                // If in label mode and contains edit operations, terminate early to prevent text modifications\r\n                // Note: Still allow operations to Label Entities / WrapNodes\r\n                if (props.labelMode === LabelMode.Label && containsEditOperation) {\r\n                    console.warn(`Edit operations blocked: `, attemptedEditOperations.map(o => o.type))\r\n                    return\r\n                }\r\n\r\n                const selectionOperations = editor.operations\r\n                    .filter(op => selectionOperationType === op.type)\r\n                const containsSelectionOperations = selectionOperations.length > 0\r\n\r\n                // Apply values changes\r\n                const customValue = value as CustomElement[]\r\n                setSlateValue(customValue)\r\n\r\n                if (props.labelMode === LabelMode.Label && containsSelectionOperations) {\r\n                    debouncedSelectionChange()\r\n                }\r\n\r\n                const isAstChange = editor.operations.some(op => selectionOperationType !== op.type)\r\n                if (isAstChange) {\r\n                    debouncedSlateValueChange(customValue)\r\n\r\n                    const text = serialize(customValue)\r\n                    const entities = CustomEditor.getEntities(editor)\r\n                    const newLabeledText: LabeledText<EntityData> = {\r\n                        text,\r\n                        entities\r\n                    }\r\n\r\n                    debouncedLabeledTextChange(newLabeledText)\r\n                }\r\n            }}\r\n        >\r\n            <EditorWrapper\r\n                ref={editorWrapperRef}\r\n                onBlur={onBlurSlateEditorWrapper}\r\n            >\r\n                <Editable\r\n                    onKeyDown={onEditableKeyDown}\r\n                    onDragStart={() => false}\r\n                    onDrop={onEditableDrop}\r\n                    renderElement={renderElementProps => renderElement(renderElementProps, debugMode)}\r\n                />\r\n                <EntityPicker\r\n                    ref={entityPickerRef}\r\n                    isVisible={pickerProps.isVisible}\r\n                    position={pickerProps.position}\r\n                    entities={props.entities}\r\n                    onClickCreate={onPickerCreateEntity}\r\n                    onSelectEntity={onSelectEntity}\r\n                    onDismissPicker={() => closePicker()}\r\n                />\r\n            </EditorWrapper>\r\n        </Slate>\r\n    )\r\n}\r\n\r\nconst EditorWrapper = styled.div`\r\n    border: 1px solid var(--color-white);\r\n    border-radius: 3px;\r\n    padding: 0.5rem;\r\n    position: relative;\r\n`\r\n\r\nconst renderElement = (props: RenderElementProps, mode: DebugMode) => {\r\n    switch (props.element.type) {\r\n        case 'paragraph':\r\n            return <ParagraphElement {...props} />\r\n        case 'entity':\r\n            return <EntityElement {...props} mode={mode} />\r\n        case 'token':\r\n            return <TokenElement {...props} mode={mode} />\r\n        default:\r\n            return <DefaultElement {...props} />\r\n    }\r\n}\r\n\r\nexport default EntityLabeler\r\n\r\nfunction getPickerProps(\r\n    parentElement: HTMLDivElement,\r\n    pickerElement: HTMLDivElement,\r\n    domSelection: Selection,\r\n) {\r\n    const parentElementRect = parentElement.getBoundingClientRect()\r\n    const domSelectionRange = domSelection.getRangeAt(0)\r\n    const domSelectionRect = domSelectionRange.getBoundingClientRect()\r\n\r\n    // Goal is to get relative coordinate offsets based on comparing absolute values\r\n    // Get relative left\r\n    const relativeSelectionLeft = domSelectionRect.left - parentElementRect.left\r\n    const halfSelectionWidth = domSelectionRect.width / 2\r\n    const centerOfSelectionLeft = relativeSelectionLeft + halfSelectionWidth\r\n    const halfPickerWidth = pickerElement.offsetWidth / 2\r\n    const relativePickerLeft = centerOfSelectionLeft - halfPickerWidth\r\n    const constrainedLeft = Math.max(0, relativePickerLeft)\r\n\r\n    // Get relative top\r\n    const pickerSpacer = 10\r\n    const relativeSelectionTop = domSelectionRect.top - parentElementRect.top\r\n    const top = relativeSelectionTop + domSelectionRect.height + pickerSpacer\r\n\r\n    const pickerProps: PickerProps = {\r\n        isVisible: true,\r\n        position: {\r\n            top,\r\n            left: constrainedLeft\r\n        }\r\n    }\r\n    return pickerProps\r\n}\r\n\r\nfunction expandSelection(\r\n    startTokenEntry: NodeEntry<Ancestor>,\r\n    endTokenEntry: NodeEntry<Ancestor>,\r\n    editor: CustomEditor\r\n) {\r\n    const [_, startTokenPath] = startTokenEntry\r\n    // Get point at start of start token\r\n    const startPoint: Point = {\r\n        path: startTokenPath,\r\n        offset: 0\r\n    }\r\n\r\n    // Get point at end of end token\r\n    const [endToken, endTokenPath] = endTokenEntry\r\n    const endPoint: Point = {\r\n        path: endTokenPath,\r\n        // There is assumption here that token contains single text element. (This could be made more robust)\r\n        offset: (endToken.children[0] as CustomText).text.length\r\n    }\r\n\r\n    const selectionLocation = {\r\n        anchor: startPoint,\r\n        focus: endPoint,\r\n    }\r\n\r\n    Transforms.select(editor, selectionLocation)\r\n}\r\n\r\n","import EntityLabeler from './EntityLabeler'\r\n// Note: Only intend to export IEntity, but CRA isolatedModules for babel error blocks\r\nexport * from './models'\r\nexport * from './utils'\r\n\r\nexport default EntityLabeler","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport { LabelMode } from './EntityLabeler'\r\n\r\ntype SliderOption = {\r\n    name: string\r\n    value: LabelMode\r\n}\r\n\r\ntype Props = {\r\n    options: SliderOption[]\r\n    selectedOption: LabelMode\r\n    onChangeSelectedOption: (mode: LabelMode) => void\r\n}\r\n\r\nexport const SliderOptions: React.FC<Props> = (props) => {\r\n    const optionsIndex = props.options.findIndex(o => o.value === props.selectedOption)\r\n    const highlightStyles = { '--optionsIndex': optionsIndex } as React.CSSProperties\r\n    return (\r\n        <Wrapper>\r\n            {props.options.map((option, i) => {\r\n                return (\r\n                    <OptionWrapper key={i} onClick={() => props.onChangeSelectedOption(option.value)}>{option.name}</OptionWrapper>\r\n                )\r\n            })}\r\n            <Highlight style={highlightStyles} />\r\n        </Wrapper>\r\n    )\r\n}\r\n\r\nexport default SliderOptions\r\n\r\nconst Wrapper = styled.div`\r\n    --optionWidth: 80;\r\n    --optionPadding: 5px;\r\n    --optionRadius: 3000px;\r\n    --optionGap: 0.5rem;\r\n\r\n    border-radius: var(--optionRadius);\r\n    border: 1px solid var(--color-slider-highlight);\r\n    display: flex;\r\n    gap: var(--optionGap);\r\n    position: relative;\r\n    font-size: 18px;\r\n`\r\n\r\nconst OptionWrapper = styled.button`\r\n    border-radius: var(--optionRadius);\r\n    width: calc(var(--optionWidth) * 1px);\r\n    background: none;\r\n    border: none;\r\n    color: white;\r\n    padding: var(--optionPadding);\r\n    z-index: 2;\r\n    text-align: center;\r\n    cursor: pointer;\r\n`\r\n\r\nconst Highlight = styled.div`\r\n    border-radius: var(--optionRadius);\r\n    background: var(--color-slider-highlight);\r\n    width: calc(var(--optionWidth) * 1px);\r\n    position: absolute;\r\n    height: 100%;\r\n    padding: var(--optionPadding);\r\n    pointer-events: none;\r\n\r\n    transform: translate(calc((var(--optionsIndex) * var(--optionGap)) + (var(--optionsIndex) * var(--optionWidth) * 1px)));\r\n    transition: transform 200ms;\r\n    will-change: transform;\r\n`","import React from 'react'\r\nimport styled from 'styled-components'\r\nimport EntityLabeler, { CustomElement, LabeledEntity, LabelMode, EntityData, Entity, LabeledText } from './components/EntityLabeler'\r\nimport SliderOptions from './components/SliderOptions'\r\nimport { v4 as uuid } from 'uuid'\r\n\r\nconst defaultText = `\r\nOK test this\r\nFourth word second word\r\nThird line, let's test this\r\n`.trim()\r\n\r\nconst defaultLabeledText: LabeledText<EntityData> = {\r\n  text: defaultText,\r\n  entities: []\r\n}\r\n\r\nconst defaultOptions = `\r\napples\r\noranges\r\npears\r\nblueberries\r\npickles\r\ncucumbers\r\nolives\r\nraspberries\r\nwatermelons\r\nplums\r\n`.trim()\r\n\r\nconst App: React.FC = () => {\r\n  const [labeledText, setLabeledText] = React.useState<LabeledText<EntityData>>(defaultLabeledText)\r\n  const [labelMode, setLabelMode] = React.useState<LabelMode>(LabelMode.EditText)\r\n  const [value, setValue] = React.useState<CustomElement[] | undefined>()\r\n  const [optionString, setOptionsString] = React.useState(defaultOptions)\r\n\r\n  const onChangeValue = (value: CustomElement[]) => {\r\n    setValue(value)\r\n  }\r\n\r\n  const onChangeLabeledText = (labeledText: LabeledText<EntityData>) => {\r\n    setLabeledText(labeledText)\r\n  }\r\n\r\n  const onChangeSelectedOption = (option: string) => {\r\n    setLabelMode(option as LabelMode)\r\n  }\r\n\r\n  const onChangeOptionsString: React.ChangeEventHandler<HTMLTextAreaElement> = event => {\r\n    setOptionsString(event.target.value)\r\n  }\r\n\r\n  const labelModeOptions = [\r\n    {\r\n      name: `1: Edit`,\r\n      value: LabelMode.EditText\r\n    },\r\n    {\r\n      name: '2: Label',\r\n      value: LabelMode.Label\r\n    }\r\n  ]\r\n\r\n  const entities = React.useMemo(() => optionString.split('\\n')\r\n    .filter(o => o.length > 0)\r\n    .map<Entity>((o, i) => {\r\n      return {\r\n        name: o,\r\n        id: uuid()\r\n      }\r\n    }), [optionString])\r\n\r\n  return (\r\n    <Wrapper>\r\n      <Header>\r\n        <h1>Slate Entity Labeler</h1>\r\n      </Header>\r\n      <main>\r\n        <ComponentSection>\r\n          <Column>\r\n            <h2>Options:</h2>\r\n            <EntityTextarea value={optionString} onChange={onChangeOptionsString} rows={5} />\r\n          </Column>\r\n          <Column>\r\n            <h2>Labeler:</h2>\r\n            <EntityLabeler\r\n              labeledText={labeledText}\r\n              labelMode={labelMode}\r\n              entities={entities}\r\n              onChangeValue={onChangeValue}\r\n              onChangeLabeledText={onChangeLabeledText}\r\n            />\r\n            <SliderOptions\r\n              options={labelModeOptions}\r\n              selectedOption={labelMode}\r\n              onChangeSelectedOption={onChangeSelectedOption}\r\n            />\r\n          </Column>\r\n        </ComponentSection>\r\n\r\n        <DataSection>\r\n          <div>\r\n            <div>\r\n              <h2>Labeled Text Value:</h2>\r\n              <CodeContainer>\r\n                <pre>\r\n                  <code>{labeledText ? JSON.stringify(labeledText, null, 4) : \"Empty\"}</code>\r\n                </pre>\r\n              </CodeContainer>\r\n            </div>\r\n            <div>\r\n              <h2>Entities:</h2>\r\n              <CodeContainer>\r\n                <pre>\r\n                  <code>{entities ? JSON.stringify(entities, null, 4) : \"Empty\"}</code>\r\n                </pre>\r\n              </CodeContainer>\r\n            </div>\r\n          </div>\r\n\r\n          <ValueDiv>\r\n            <h2>Slate Value:</h2>\r\n            <CodeContainer>\r\n              <pre>\r\n                <code>{value ? JSON.stringify(value, null, 4) : \"Empty\"}</code>\r\n              </pre>\r\n            </CodeContainer>\r\n          </ValueDiv>\r\n        </DataSection>\r\n      </main>\r\n    </Wrapper>\r\n  )\r\n}\r\n\r\nconst Wrapper = styled.div`\r\n  padding: 2rem;\r\n  font-size: 2rem;\r\n  position: relative;\r\n`\r\n\r\nconst Header = styled.header`\r\n  text-align: center;\r\n`\r\n\r\nconst ComponentSection = styled.section`\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr;\r\n  gap: 2rem;\r\n`\r\n\r\nconst Column = styled.div`\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n`\r\n\r\nconst DataSection = styled.section`\r\n  display: grid;\r\n  grid-template-columns: 1fr 1fr;\r\n  gap: 2rem;\r\n`\r\n\r\nconst ValueDiv = styled.div`\r\n`\r\n\r\nconst EntityTextarea = styled.textarea`\r\n  border-radius: 3px;\r\n  border: 1px solid var(--color-gray-300);\r\n  padding: 0.25rem;\r\n  font-size: 1rem;\r\n  font: var(--font-family-sans-serif);\r\n  background: transparent;\r\n  color: var(--color-gray-100);\r\n`\r\n\r\nconst CodeContainer = styled.div`\r\n  border-radius: 4px;\r\n  border: 1px solid var(--color-white);\r\n  font-size: 1rem;\r\n  padding: 0.25em;\r\n\r\n  & pre {\r\n    margin: 0;\r\n    padding: 0;\r\n  }\r\n`\r\n\r\nexport default App\r\n","\r\n\r\nexport const COLORS = {\r\n    white: 'hsl(0deg 0% 100%)',\r\n    offblack: 'hsl(24deg 5% 6%)',\r\n    gray: {\r\n        100: 'hsl(40deg 12% 95%)',\r\n        300: 'hsl(35deg 8% 80%)',\r\n        500: 'hsl(30deg 4% 60%)',\r\n        700: 'hsl(28deg 5% 40%)',\r\n        900: 'hsl(24deg 6% 16%)',\r\n    },\r\n    primary: 'hsl(224deg 30% 40%)',\r\n    secondary: 'hsl(180deg 34% 37%)',\r\n    urgent: 'hsl(0deg 55% 54%)',\r\n    slider: {\r\n        highlight: `hsl(80deg 80% 40% / 0.8)`,\r\n    },\r\n    picker: {\r\n        highlight: 'hsl(120deg 40% 70%)',\r\n        hover: 'hsl(120deg 45% 80%)',\r\n    },\r\n    entities: {\r\n        background: `hsl(120deg 50% 80% / 0.2)`,\r\n        border: `hsl(120deg 50% 80% / 0.4)`,\r\n        name: `hsl(120deg 30% 50%)`,\r\n        highlight: `hsl(120deg 40% 60%)`,\r\n    },\r\n    token: {\r\n        base: `hsl(180deg 50% 80% / 0.4)`,\r\n    }\r\n}\r\n\r\nexport const WEIGHTS = {\r\n    normal: 400,\r\n    medium: 550,\r\n    bold: 700,\r\n}\r\n\r\nexport const FAMILIES = {\r\n    serif: '\"Crimson Pro\", Georgia, serif',\r\n    sansSerif:\r\n        `-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\r\n        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\r\n        sans-serif;`,\r\n    code: `source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;`\r\n}","import { createGlobalStyle } from 'styled-components'\r\nimport { COLORS, WEIGHTS, FAMILIES } from './constants'\r\n\r\nconst GlobalStyles = createGlobalStyle`\r\n    html, body {\r\n        height: 100%;\r\n    }\r\n\r\n    body {\r\n        margin: 0;\r\n        padding: 0;\r\n\r\n        font-family: var(--font-family-sans-serif);\r\n        background-color: var(--color-gray-900);\r\n        color: var(--color-white);\r\n        font-size: 16px;\r\n\r\n        -webkit-font-smoothing: antialiased;\r\n    }\r\n\r\n    code {\r\n        font-family: var(--font-family-code);\r\n    }\r\n\r\n    *,\r\n    *:before,\r\n    *:after {\r\n        box-sizing: border-box;\r\n    }\r\n\r\n    #root {\r\n        isolation: isolate;\r\n        min-height: 100%;\r\n    }\r\n\r\n    h1, h2, h3 {\r\n        line-height: 1.5;\r\n        margin: 0.25em 0;\r\n    }\r\n\r\n    :root {\r\n        --color-white: ${COLORS.white};\r\n        --color-offblack: ${COLORS.offblack};\r\n        --color-gray-100: ${COLORS.gray[100]};\r\n        --color-gray-300: ${COLORS.gray[300]};\r\n        --color-gray-500: ${COLORS.gray[500]};\r\n        --color-gray-700: ${COLORS.gray[700]};\r\n        --color-gray-900: ${COLORS.gray[900]};\r\n        --color-primary: ${COLORS.primary};\r\n        --color-secondary: ${COLORS.secondary};\r\n        --color-urgent: ${COLORS.urgent};\r\n\r\n        --color-slider-highlight: ${COLORS.slider.highlight};\r\n\r\n        --color-picker-highlighted: ${COLORS.picker.highlight};\r\n        --color-picker-hover: ${COLORS.picker.hover};\r\n        --color-entities-background: ${COLORS.entities.background};\r\n        --color-entities-border: ${COLORS.entities.border};\r\n        --color-entities-name: ${COLORS.entities.name};\r\n        --color-entities-name-highlight: ${COLORS.entities.highlight};\r\n        --color-token-base: ${COLORS.token.base};\r\n\r\n        --font-weight-normal: ${WEIGHTS.normal};\r\n        --font-weight-medium: ${WEIGHTS.medium};\r\n        --font-weight-bold: ${WEIGHTS.bold};\r\n\r\n        --font-family-serif: ${FAMILIES.serif};\r\n        --font-family-sans-serif: ${FAMILIES.sansSerif};\r\n        --font-family-code: ${FAMILIES.code};\r\n    }\r\n`\r\n\r\nexport default GlobalStyles","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport GlobalStyles from './GlobalStyles'\n\nReactDOM.render(<>\n    <App />\n    <GlobalStyles /> \n</>, document.getElementById('root'))\n"],"sourceRoot":""}